{
  "Type": "Article",
  "Name": "auto keyword",
  "Information": "A placeholder type specifier may appear in the following contexts:\n\nin the type specifier of a variable: auto x = expr;. The type is deduced from the initializer.\nIf the placeholder type specifier is auto or type-constraint auto (since C++20), the variable type is deduced from the initializer using the rules for template argument deduction from a function call (see template argument deduction â€” other contexts for details).\nFor example, given const auto& i = expr;, the type of i is exactly the type of the argument u in an imaginary template template<class U> void f(const U& u) if the function call f(expr) was compiled. Therefore, auto&& may be deduced either as an lvalue reference or rvalue reference according to the initializer, which is used in range-based for loop.\nIf the placeholder type specifier is decltype(auto) or type-constraint decltype(auto) (since C++20), the deduced type is decltype(expr), where expr is the initializer.\n\n(since C++14)\nIf the placeholder type specifier is used to declare multiple variables, the deduced types must match. ",
  "Difficulty": 1,
  "RelatedThemes": [
    "theme_Basic"
  ],
  "Links": [
    "https://docs.microsoft.com/en-us/cpp/cpp/auto-cpp?view=msvc-170",
    "https://en.cppreference.com/w/cpp/language/auto"
  ],
  "Theme": [
    {
      "Name": "theme_Basic",
      "Weight": 1.0
    }
  ],
  "DirectTasks": [

  ]
}
