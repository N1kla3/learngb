{
  "Type": "Article",
  "Name": "Move semantics",
  "Information": "To understand the move semantics first let’s look at copy semantics. In general, all classes in C++ can be copied using one of special methods:\nCopy constructor\nT t1;\nT t2(t1);\nCopy assignment operator\nT t1, t2;\nt2 = t1;\nSimilarly C++11 defined another two methods in order to allow moving objects instead of copying:\nMove constructor\nT t1;\nT t2(std::move(t1));\nMove assignment operator\nT t1, t2;\nt2 = std::move(t1);\nIn general, move semantics allows us to take an object from the current context and pass it to another one, avoiding copy when the original object is not needed anymore. If we want to move objects, we need to use std::move function, as in the above example.\nIt is also worth to mention about 2 issues related to these examples:\nWhat happens with the t1 variable after the move? According to C++ standard variable after the move is in „valid but unspecified state”. It means we can perform operations that does not need preconditions (e.g. assign new object)\nHow does std::move work? In fact std::move doesn’t move anything. To find out what std::move really is we need to dig into rvalues.\nLvalues vs. rvalues\nIn C++ (unlike the C) a variable can be declared as reference. Before C++11 reference could point only to lvalue (something whose address can be taken):\nint counter = 10;\nint& counterRef = counter;\nSince C++11 reference can point to lvalue or rvalue. Rvalue reference is basically reference to temporary object (right-hand side of an assignment expression), e.g.:\nint&& counterRef = 10;\nThe role of rvalue references in move semantics\nAs mentioned earlier, there are 4 special methods for handling copy/move operations. Let’s look at their definitions:\nClass Point\n{\n…\nPoint (const Point& point);//copy constructor\nPoint& operator(const Point& point);//copy assigment operator\nPoint(Point&& point);//move constructor\nPoint& operator=(Point&& point);//move assigment operator\n…\n}\nAs we can see copy operations take lvalue reference while move operations take rvalue reference, so the object is being copied or moved depending on the reference type. And this is what std::move function does — it just converts lvalue reference to rvalue reference.\nWhen to use move semantics\nWhen method takes rvalue as parameter, we can pass rvalue reference (reference to temporary object) but also temporary object itself:\n100\n„temp”\nPoint()\nIt is a good practice to create overloads for methods takings lvalues and rvalues e.g. a few STL containers have two push_back methods:\nvoid push_back(const T& obj);\nvoid push_back(T&& obj);\nIt allows us to create copy (if object is still needed in this context) or move (if object is not needed):\nstd::vector<Point> points;\nPoint point1, point2;\npoints.push_back(point1);//lvalue\npoints.push_back(std::move(point2));//rvalue\nThis is typical usage of move semantics.\nWhen not to use move semantics\nCommon mistake made by developers is using std::move when the local variable is returned from the function.\nstd::vector<int> getNumbers() const\n{\nstd::vector<int> numbers = {1,2,3};\nreturn std::move(numbers);\n}\nauto numbers = getNumbers();\nIn this case there are 2 objects created:\nLocal variable numbers inside getNumbers function — temporary object\nLeft hand side object where getNumbers is called — this object is created using move constructor\nThe issue here is that the compiler by default uses an optimization technique called RVO (Return Value Optimization) in order to avoid copies of temporary objects. Let’s remove std::move from code:\nstd::vector<int> getNumbers() const\n{\nstd::vector<int> numbers = {1,2,3};\nreturn numbers;\n}\nWithout RVO there are 3 vector instances created:\nLocal variable numbers inside getNumbers function — temporary object\nRight hand side object where getNumbers is called — temporary object\nLeft hand side object where getNumbers is called\nBut with RVO there is only one instance created.",
  "Difficulty": 3,
  "RelatedThemes": [
    "theme_move_semantics"
  ],
  "Links": [
    "https://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html",
    "https://www.internalpointers.com/post/c-rvalue-references-and-move-semantics-beginners"
  ],
  "Theme": [
    {
      "Name": "theme_move_semantics",
      "Weight": 1.1
    }
  ],
  "DirectTasks": [
  ]
}
