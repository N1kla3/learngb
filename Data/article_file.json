{
  "Type": "Article",
  "Name": "Files",
  "Information": "In your programming journey, there will come a time when you’ll want to start working with real-world data. This kind of data is typically stored in files on disk. Since reading from files involves interacting with your operating system, it amounts to a rather complex task. In this article, we’ll look at C++ streams, file handling, and three different methods for reading data from a file into a C++ program. \n\nIf you come from a high-level programming language like Python, reading a file into a program seems like a simple enough task. You open the file, read its contents and close it. Working with a file might take up one or two lines of your code. In C++, the workflow of reading a file is a bit more complex — there is the added step of reading to or from a stream object. To understand how our C++ programs interact with files, let us now take a look at the concept of streams in C++. \n\nWhat Are C++ Streams?\nC++ streams are interfaces for processing sequence-like input and output. If you’ve written a “Hello World” program in C++ before, then you have worked with streams. Let’s briefly go over how this would look:\n\nstd::cout << \"Hello World!\\n\";\nIn this example, we stream our string object into the character output stream (“cout” for short). cout is part of the iostream library, and an instance of the more general class of output streams (“ostream”). ostream’s sister class is “istream,” a class for handling input streams. \n\nWhen working with files, we employ another subclass of streams: the fstream class (for file stream) consists of ifstreams for input and ofstreams for output to file. For this example, we’ll work with ifstreams, since they allow us to read from a file. \n\nFile Handling in C++\nTo read a character sequence from a text file, we’ll need to perform the following steps:\n\nCreate a stream object. \nConnect it to a file on disk. \nRead the file’s contents into our stream object. \nClose the file.\nThe  steps that we examine in detail below, register under the action of “file handling.” At each stage, our stream object may occupy different states, which we can check for using the following member functions:\n\nbad() returns True if an error occurred while reading from or writing to a stream. If a stream is “bad,” no further operations involving the stream are possible.\nfail() returns True if an error occurs, but we can still operate on the  stream.\neof() returns True if the end of the file (EOF) is reached, with False returned otherwise.\ngood() returns True if each of the other three states are false, i.e., the stream is neither bad nor failed, nor has it reached the end of the file. \nAnother important method is provided by is_open(). It evaluates to True if a stream object is open. Let’s now finally bring all the components together and read in a file in C++.\n\nRead a File in C++\nSay we have a shopping list stored in a .txt file:\n\neggs\nham\neggs and spam\nspam and eggs\nOur goal is to print the list’s contents to the console. Before we start writing our program, let’s include the relevant header files:\n\n#include <iostream>\n#include <fstream>\n#include <string>\nWe’re now ready to write our function. Let’s first declare our fstream variable and connect it to a stream object by opening the file:\n\nint main () {\nstd::ifstream myfile; myfile.open(\"shopping_list.txt\");\nStrictly speaking, we could have performed that action in a single line, using the class constructor to open the file directly when initializing the stream object:\n\nint main () {\nstd::ifstream myfile (\"shopping_list.txt\"); // this is equivalent to the above method\nBefore we get to read the file’s contents into our stream, all that’s left to do is to declare a string variable that can hold the contents:\n\nstd::string mystring;\nRead a File in C++ Using the >> Operator\nFor starters, let’s use the stream input operator >> to read in our list from the file.\n\nif ( myfile.is_open() ) { // always check whether the file is open\nmyfile >> mystring; // pipe file's content into stream\nstd::cout << mystring; // pipe stream's content to standard output\n}\nNote that the ifstream destructor closes our file automatically,  which is one of the perks of using this class. If we wanted, we could have added an infile.close() command to the end of the program. This is seen as good practice, but it does not really add any value.\n\nWhen we run that function, here’s the output we get on the screen:\n\neggs\nThat’s not what we expected. Our function printed only the first item of our shopping list. That’s because the >> operator reads a string only until it encounters a white space character (such as a space or line break). To read the entire file, we can place the line into a while loop:\n\nif ( myfile.is_open() ) {     while ( myfile.good() ) {\nmyfile >> mystring;\nstd::cout << mystring;\n}          }\nOnce we reach the end of the file, myfile.good() evaluates to False, causing the while loop to terminate. We can abbreviate the condition as follows:\n\nwhile ( myfile ) {\nThis is equivalent to asking if our file is good. How does our code perform now?\n\neggshameggsandspamspamandeggseggs\nTwo things happened here: All our shopping items got chained together, with the last item being printed twice. While the latter has to do with how C++ handles buffered data and is out of the scope of this tutorial, the first was to be expected. After all, >> ignores whitespace, meaning that all the space and newline characters get lost. How can we include that information in the output? The answer to that question lies in the get() function.",
  "Difficulty": 2,
  "RelatedThemes": [
  ],
  "Links": [
    "https://www.w3schools.com/cpp/cpp_files.asp",
    "https://www.tutorialspoint.com/cplusplus/cpp_files_streams.htm"
  ],
  "Theme": [
    {
      "Name": "theme_Basic",
      "Weight": 1.0
    }
  ],
  "DirectTasks": [
  ]
}
